#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail

# Function to test bocker container runs and check their output
function bocker_run_test() {
    local image="$1"
    local command="$2"
    local expected="$3"
    local max_retries=10
    local retry_count=0
    
    echo "# Running command: $command"
    
    # Capture the bocker run output to get any immediate feedback
    local run_output
    run_output="$(./bocker run "$image" "$command" 2>&1)" || {
        echo "# Test FAILED: bocker run command failed"
        echo "# Run output: $run_output"
        echo 1
        return
    }
    
    # Wait a moment for the container to appear in ps output
    sleep 0.5
    
    # Try to find the container ID with retries
    local ps=""
    while [[ $retry_count -lt $max_retries ]]; do
        ps="$(./bocker ps 2>/dev/null | grep "$command" | awk '{print $1}' | head -1)" || true
        
        if [[ -n "$ps" ]]; then
            echo "# Container ID for '$command': $ps"
            break
        fi
        
        ((retry_count++))
        echo "# Retry $retry_count/$max_retries: Looking for container..."
        sleep 0.2
    done
    
    # If we still can't find the container, check if it completed immediately
    if [[ -z "$ps" ]]; then
        echo "# Container not found in ps output - checking for completed containers"
        
        # Look for any recent container directories that might match
        local recent_containers
        recent_containers="$(find /var/bocker -maxdepth 1 -name 'ps_*' -newermt '10 seconds ago' 2>/dev/null)" || true
        
        if [[ -n "$recent_containers" ]]; then
            # Try to find a container that ran our command
            for container_dir in $recent_containers; do
                local container_id
                container_id="$(basename "$container_dir")"
                
                if [[ -f "$container_dir/$container_id.cmd" ]]; then
                    local stored_cmd
                    stored_cmd="$(cat "$container_dir/$container_id.cmd" 2>/dev/null)" || continue
                    
                    if [[ "$stored_cmd" == "$command" ]]; then
                        ps="$container_id"
                        echo "# Found completed container ID: $ps"
                        break
                    fi
                fi
            done
        fi
        
        if [[ -z "$ps" ]]; then
            echo "# Test FAILED: Could not find container for command '$command'"
            echo "# Available containers:"
            ./bocker ps || echo "# No containers found"
            echo 1
            return
        fi
    fi
    
    # Get the logs from the container
    local logs
    if ! logs="$(./bocker logs "$ps" 2>/dev/null)"; then
        echo "# Test FAILED: Could not retrieve logs for container $ps"
        echo "# Checking if log file exists..."
        if [[ -f "/var/bocker/$ps/$ps.log" ]]; then
            echo "# Log file exists, attempting direct read..."
            logs="$(cat "/var/bocker/$ps/$ps.log" 2>/dev/null)" || logs="<unable to read log file>"
        else
            echo "# Log file does not exist at /var/bocker/$ps/$ps.log"
            logs="<no logs available>"
        fi
    fi
    
    echo "# Logs output: $logs"
    
    # Check if expected string is in the logs
    if [[ "$logs" == *"$expected"* ]]; then
        echo "# Test PASSED: Found '$expected' in logs"
        echo 0
    else
        echo "# Test FAILED: '$expected' not found in logs"
        echo "# Full logs content:"
        echo "$logs" | sed 's/^/# /'
        echo 1
    fi
}

# Function to run a container and wait for completion (for non-test commands)
function bocker_run_and_wait() {
    local image="$1"
    local command="$2"
    local max_wait=30
    local wait_count=0
    
    echo "# Running: $command"
    ./bocker run "$image" "$command" > /dev/null 2>&1 &
    local run_pid=$!
    
    # Wait for the run command to complete
    while kill -0 $run_pid 2>/dev/null && [[ $wait_count -lt $max_wait ]]; do
        sleep 1
        ((wait_count++))
    done
    
    # Give it a moment to show up in ps
    sleep 1
    
    # Find the container
    local ps
    ps="$(./bocker ps | grep "$command" | awk '{print $1}' | head -1)" || {
        echo "# Warning: Could not find container for '$command'"
        return 1
    }
    
    echo "# Container ID: $ps"
    echo "$ps"
}

# Initialize a new image from ~/base-image and extract the image ID
img="$(./bocker init ~/base-image | awk '{print $2}')"
echo "# Created image with ID: $img"

# Verify the image appears in the images list
if ./bocker images | grep -qw "$img"; then
    echo "# Image verification: SUCCESS"
else
    echo "# Image verification: FAILED"
    exit 1
fi

# Test 1: Run 'echo foo' and expect 'foo' in output
echo "# Running test 1: echo foo"
if [[ "$(bocker_run_test "$img" 'echo foo' 'foo')" == 0 ]]; then
    echo "# Test 1 completed successfully"
else
    echo "# Test 1 FAILED"
    exit 1
fi

# Test 2: Run 'uname' and expect 'Linux' in output
echo "# Running test 2: uname"
if [[ "$(bocker_run_test "$img" 'uname' 'Linux')" == 0 ]]; then
    echo "# Test 2 completed successfully"
else
    echo "# Test 2 FAILED"
    exit 1
fi

# Test 3: Check process isolation - cat should show PID 1
echo "# Running test 3: process isolation check"
if [[ "$(bocker_run_test "$img" 'cat /proc/self/stat' '1 (cat)')" == 0 ]]; then
    echo "# Test 3 completed successfully - process isolation working"
else
    echo "# Test 3 FAILED"
    exit 1
fi

# Install iproute package in a container
echo "# Installing iproute package..."
if ps_id="$(bocker_run_and_wait "$img" 'yum install -y iproute')"; then
    echo "# Installation container ID: $ps_id"
    
    # Commit the changes to create a new image layer
    ./bocker commit "$ps_id" "$img"
    echo "# Committed changes to image $img"
else
    echo "# Failed to install iproute package"
    exit 1
fi

# Test 4: Verify network interface setup (should show veth1 interface)
echo "# Running test 4: network interface check"
if [[ "$(bocker_run_test "$img" 'ip addr' 'veth1')" == 0 ]]; then
    echo "# Test 4 completed successfully - network interfaces configured"
else
    echo "# Test 4 FAILED"
    exit 1
fi

# Test 5: Test external connectivity to Google DNS
echo "# Running test 5: external DNS connectivity"
if [[ "$(bocker_run_test "$img" 'ping -c 1 8.8.8.8' '0% packet loss')" == 0 ]]; then
    echo "# Test 5 completed successfully - can reach 8.8.8.8"
else
    echo "# Test 5 FAILED"
    exit 1
fi

# Test 6: Test DNS resolution and connectivity
echo "# Running test 6: DNS resolution and connectivity"
if [[ "$(bocker_run_test "$img" 'ping -c 1 google.com' '0% packet loss')" == 0 ]]; then
    echo "# Test 6 completed successfully - DNS resolution working"
else
    echo "# Test 6 FAILED"
    exit 1
fi

echo "# All tests completed successfully!"
